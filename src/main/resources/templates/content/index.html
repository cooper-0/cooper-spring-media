<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"
    xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout" layout:decorate="~{layout/default_layout}">

<th:block layout:fragment="head">
    <title>Index</title>

    <!--/* 부트스트랩 */-->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>

    <link rel="stylesheet" th:href="@{css/sidebars.css}">

    <!-- 웹소캣 연결에 필요한 라이브러리 선언 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.5.1/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>

</th:block>

<body>
    <th:block layout:fragment="header" th:include="@{fragments/header}"></th:block>

    <div layout:fragment="content" class="content">
        <main>
            <div class="flex-shrink-0 p-3 bg-white" style="width: 20%;">
                <ul class="list-unstyled ps-0">
                    <li class="mb-1">
                        <button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse"
                            data-bs-target="#home-collapse" aria-expanded="false">
                            테스트
                        </button>
                        <div class="collapse" id="home-collapse">
                            <ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small">
                                <li><a href="#" class="link-dark rounded">Overview</a></li>
                                <li><a href="#" class="link-dark rounded">Updates</a></li>
                                <li><a href="#" class="link-dark rounded">Reports</a></li>
                            </ul>
                        </div>
                    </li>
                    <li class="mb-1">
                        <button class="btn btn-toggle align-items-center rounded collapsed" data-bs-toggle="collapse"
                            data-bs-target="#dashboard-collapse" aria-expanded="true">
                            음성 채널
                        </button>

                        <button class="btn btn-toggle btn-plus" onclick="location.href='index/create'"
                            style="text-align:right"></button>
                        <div class="collapse show" id="dashboard-collapse">
                            <ul class="btn-toggle-nav list-unstyled fw-normal pb-1 small">
                                <th:block th:each="cl : ${channelList}">
                                    <li><a href="#" class="link-dark rounded" th:text="${cl.channelName}"
                                            th:attr="data-channel-id=${cl.id}" onclick="channelClick(this)"></a></li>
                                </th:block>
                            </ul>
                        </div>
                    </li>
                </ul>
            </div>

            <div class="b-example-divider">

                <button type="button" id="startSteamBtn" style="display: none;">start Streams</button>

                <!-- 내 웹캠 화면을 보여주는 video html -->
                <video id="localStream" autoplay playsinline controls style="display: none;"></video>

                <!-- WebRTC에 연결된 웹캠들이 추가되는 Div  -->
                <div id="remoteStreamDiv"></div>

            </div>

        </main>

    </div>

    <th:block layout:fragment="footer" th:include="@{fragments/footer}"></th:block>

    <script>
        // let remoteStreamElement = document.querySelector('#remoteStream');
        let localStreamElement = document.querySelector("#localStream");
        const myKey = Math.random().toString(36).substring(2, 11);
        let pcListMap = new Map();
        let roomId;
        let otherKeyList = [];
        let localStream = undefined;

        const startCam = async () => {
            if (navigator.mediaDevices !== undefined) {
                console.log("undefined");

                const initialContrains = {
                    audio: true,
                    video: true
                } // 특별한 요구사항 없이 오디오와 비디오 요청

                try {
                    stream = await navigator.mediaDevices.getUserMedia(initialContrains);
                    // const video = document.createElement('video');
                    // video.srcObject = stream;
                    console.log("Stream found");
                    //웹캠, 마이크의 스트림 정보를 글로벌 변수로 저장한다.
                    localStream = stream;
                    // Disable the microphone by default
                    stream.getAudioTracks()[0].enabled = true;
                    localStreamElement.srcObject = localStream;

                } catch(error) {
                    console.error("Error accessing media devices:", error);
                }
            } else {
                console.log("defined");
            }
        };

        // 소켓 연결
        const connectSocket = async () => {
            const socket = new SockJS("/cooper-media/signaling");
            stompClient = Stomp.over(socket);
            stompClient.debug = null;

            stompClient.connect({}, function () {
                console.log("Connected to WebRTC server");

                //iceCandidate peer 교환을 위한 subscribe
                stompClient.subscribe(
                    `/topic/peer/iceCandidate/${myKey}/${roomId}`,
                    (candidate) => {
                        const key = JSON.parse(candidate.body).key;
                        const message = JSON.parse(candidate.body).body;

                        // 해당 key에 해당되는 peer 에 받은 정보를 addIceCandidate 해준다.
                        pcListMap
                            .get(key)
                            .addIceCandidate(
                                new RTCIceCandidate({
                                    candidate: message.candidate,
                                    sdpMLineIndex: message.sdpMLineIndex,
                                    sdpMid: message.sdpMid,
                                })
                            );
                    }
                );

                //offer peer 교환을 위한 subscribe
                stompClient.subscribe(`/topic/peer/offer/${myKey}/${roomId}`, (offer) => {
                    const key = JSON.parse(offer.body).key;
                    const message = JSON.parse(offer.body).body;

                    // 해당 key에 새로운 peerConnection 를 생성해준후 pcListMap 에 저장해준다.
                    pcListMap.set(key, createPeerConnection(key));
                    // 생성한 peer 에 offer정보를 setRemoteDescription 해준다.
                    pcListMap
                        .get(key)
                        .setRemoteDescription(
                            new RTCSessionDescription({ type: message.type, sdp: message.sdp })
                        );
                    //sendAnswer 함수를 호출해준다.
                    sendAnswer(pcListMap.get(key), key);
                });

                //answer peer 교환을 위한 subscribe
                stompClient.subscribe(`/topic/peer/answer/${myKey}/${roomId}`, (answer) => {
                    const key = JSON.parse(answer.body).key;
                    const message = JSON.parse(answer.body).body;

                    // 해당 key에 해당되는 Peer 에 받은 정보를 setRemoteDescription 해준다.
                    pcListMap
                        .get(key)
                        .setRemoteDescription(new RTCSessionDescription(message));
                });

                //key를 보내라는 신호를 받은 subscribe
                stompClient.subscribe(`/topic/call/key`, (message) => {
                    //자신의 key를 보내는 send
                    stompClient.send(`/app/send/key`, {}, JSON.stringify(myKey));
                });

                //상대방의 key를 받는 subscribe
                stompClient.subscribe(`/topic/send/key`, (message) => {
                    const key = JSON.parse(message.body);

                    //만약 중복되는 키가 ohterKeyList에 있는지 확인하고 없다면 추가해준다.
                    if (
                        myKey !== key &&
                        otherKeyList.find((mapKey) => mapKey === myKey) === undefined
                    ) {
                        otherKeyList.push(key);
                    }
                });
            });
        };

        let onTrack = (event, otherKey) => {
            if (document.getElementById(`${otherKey}`) === null) {
                const video = document.createElement("video");

                video.autoplay = true;
                video.controls = true;
                video.id = otherKey;
                video.srcObject = event.streams[0];

                document.getElementById("remoteStreamDiv").appendChild(video);
            }

            //
            // remoteStreamElement.srcObject = event.streams[0];
            // remoteStreamElement.play();
        };

        const createPeerConnection = (otherKey) => {
            const pc = new RTCPeerConnection();
            try {
                pc.addEventListener("icecandidate", (event) => {
                    onIceCandidate(event, otherKey);
                });
                pc.addEventListener("track", (event) => {
                    onTrack(event, otherKey);
                });
                if (localStream !== undefined) {
                    localStream.getTracks().forEach((track) => {
                        pc.addTrack(track, localStream);
                    });
                }

                console.log("PeerConnection created");
            } catch (error) {
                console.error("PeerConnection failed: ", error);
            }
            return pc;
        };

        let onIceCandidate = (event, otherKey) => {
            if (event.candidate) {
                console.log("ICE candidate");
                stompClient.send(
                    `/app/peer/iceCandidate/${otherKey}/${roomId}`,
                    {},
                    JSON.stringify({
                        key: myKey,
                        body: event.candidate,
                    })
                );
            }
        };

        let sendOffer = (pc, otherKey) => {
            pc.createOffer().then((offer) => {
                setLocalAndSendMessage(pc, offer);
                stompClient.send(
                    `/app/peer/offer/${otherKey}/${roomId}`,
                    {},
                    JSON.stringify({
                        key: myKey,
                        body: offer,
                    })
                );
                console.log("Send offer");
            });
        };

        let sendAnswer = (pc, otherKey) => {
            pc.createAnswer().then((answer) => {
                setLocalAndSendMessage(pc, answer);
                stompClient.send(
                    `/app/peer/answer/${otherKey}/${roomId}`,
                    {},
                    JSON.stringify({
                        key: myKey,
                        body: answer,
                    })
                );
                console.log("Send answer");
            });
        };

        const setLocalAndSendMessage = (pc, sessionDescription) => {
            pc.setLocalDescription(sessionDescription);
        };

        async function channelClick(element) {
            roomId = element.getAttribute("data-channel-id");
            console.log("Clicked Channel ID: " + roomId);

            //실행할 내용
            await startCam();

            if (localStream !== undefined) {
                document.querySelector('#localStream').style.display = 'block';
                document.querySelector('#startSteamBtn').style.display = '';
            }

            await connectSocket();
        }

        // 스트림 버튼 클릭시 , 다른 웹 key들 웹소켓을 가져 온뒤에 offer -> answer -> iceCandidate 통신
        // peer 커넥션은 pcListMap 으로 저장
        document.querySelector("#startSteamBtn").addEventListener("click", async () => {
            await stompClient.send(`/app/call/key`, {}, {});

            setTimeout(() => {
                otherKeyList.map((key) => {
                    if (!pcListMap.has(key)) {
                        pcListMap.set(key, createPeerConnection(key));
                        sendOffer(pcListMap.get(key), key);
                    }
                });
            }, 1000);
        });

    </script>

</body>

</html>